# <%= @root_namespace %> Workflows

This directory contains workflow orchestration classes that compose multiple agents. Workflows provide patterns for sequential, parallel, and conditional agent execution.

## Workflow Types

| Type | Class | Description |
|------|-------|-------------|
| Pipeline | `Workflow::Pipeline` | Sequential execution, data flows between steps |
| Parallel | `Workflow::Parallel` | Concurrent execution with aggregation |
| Router | `Workflow::Router` | Conditional dispatch based on classification |

## Creating Workflows

### Pipeline (Sequential)

Execute agents in order, passing each step's output to the next:

```ruby
module <%= @root_namespace %>
  class ContentPipeline < RubyLLM::Agents::Workflow::Pipeline
    version "1.0"
    timeout 120
    max_cost 0.50

    step :extract,  agent: ExtractorAgent
    step :validate, agent: ValidatorAgent
    step :format,   agent: FormatterAgent
  end
end
```

### Parallel (Concurrent)

Execute multiple agents simultaneously:

```ruby
module <%= @root_namespace %>
  class ReviewAnalyzer < RubyLLM::Agents::Workflow::Parallel
    version "1.0"

    branch :sentiment,  agent: SentimentAgent
    branch :summary,    agent: SummaryAgent
    branch :categories, agent: CategoryAgent

    def aggregate(results)
      {
        sentiment: results[:sentiment]&.content,
        summary: results[:summary]&.content,
        categories: results[:categories]&.content
      }
    end
  end
end
```

### Router (Conditional)

Route to different agents based on classification:

```ruby
module <%= @root_namespace %>
  class SupportRouter < RubyLLM::Agents::Workflow::Router
    version "1.0"
    classifier ClassificationAgent

    route :billing,   agent: BillingAgent
    route :technical, agent: TechnicalAgent
    route :general,   agent: GeneralAgent

    default_route :general
  end
end
```

## DSL Reference

### Shared Options

```ruby
version "1.0"        # Version for tracking changes
timeout 120          # Total workflow timeout in seconds
max_cost 0.50        # Maximum allowed cost in USD
description "..."    # Human-readable description
```

### Pipeline DSL

```ruby
# Define steps
step :name, agent: AgentClass

# Conditional skipping
step :validate, agent: Validator, skip_on: ->(ctx) { ctx[:skip_validation] }

# Optional steps (failures won't stop pipeline)
step :enrich, agent: Enricher, optional: true

# Continue on error
step :notify, agent: Notifier, continue_on_error: true
```

### Parallel DSL

```ruby
# Define branches
branch :name, agent: AgentClass

# Optional branches
branch :extra, agent: ExtraAgent, optional: true

# Custom input transformation
branch :process, agent: Processor, input: ->(opts) { { text: opts[:content] } }

# Fail-fast (stop all on first required failure)
fail_fast true

# Limit concurrency
concurrency 3
```

### Router DSL

```ruby
# Set classifier
classifier ClassificationAgent

# Define routes
route :category, agent: AgentClass

# Default route
default_route :fallback

# Custom routing logic
def select_route(classification)
  case classification[:type]
  when "urgent" then :priority
  else :standard
  end
end
```

## Using Workflows

### Basic Execution

```ruby
result = <%= @root_namespace %>::ContentPipeline.call(text: "raw input")

result.success?      # All steps succeeded
result.partial?      # Some steps succeeded
result.error?        # Workflow failed
result.content       # Final output
result.total_cost    # Combined cost
result.duration_ms   # Total duration
```

### Pipeline Results

```ruby
result = <%= @root_namespace %>::ContentPipeline.call(text: "input")

result.steps                     # Hash of all step results
result.steps[:extract].content   # Specific step output
result.errors                    # Hash of step errors
```

### Parallel Results

```ruby
result = <%= @root_namespace %>::ReviewAnalyzer.call(text: "Great product!")

result.branches                     # Hash of branch results
result.branches[:sentiment].content # Specific branch output
```

### Router Results

```ruby
result = <%= @root_namespace %>::SupportRouter.call(question: "How do I pay?")

result.classification  # What route was selected
result.route          # Which agent handled it
result.content        # Response from routed agent
```

## Advanced Patterns

### Input Transformation

Transform data between pipeline steps:

```ruby
module <%= @root_namespace %>
  class TransformPipeline < RubyLLM::Agents::Workflow::Pipeline
    step :analyze, agent: AnalyzerAgent
    step :enrich,  agent: EnricherAgent

    # Called before :enrich step
    def before_enrich(context)
      {
        data: context[:analyze].content,
        extra_field: "additional context"
      }
    end
  end
end
```

### Custom Aggregation

Combine parallel results:

```ruby
module <%= @root_namespace %>
  class SafetyChecker < RubyLLM::Agents::Workflow::Parallel
    branch :toxicity, agent: ToxicityAgent
    branch :spam,     agent: SpamAgent
    branch :pii,      agent: PiiAgent

    def aggregate(results)
      {
        is_safe: results.values.none? { |r| r&.content == "flagged" },
        flags: results.select { |_, r| r&.content == "flagged" }.keys
      }
    end
  end
end
```

### Error Handling

Handle step failures:

```ruby
module <%= @root_namespace %>
  class ResilientPipeline < RubyLLM::Agents::Workflow::Pipeline
    step :primary, agent: PrimaryAgent
    step :backup,  agent: BackupAgent, optional: true

    # Called when :primary fails
    def on_primary_failure(error, context)
      Rails.logger.warn("Primary failed: #{error.message}")
      :skip  # Continue to backup
      # :abort would stop the pipeline
    end
  end
end
```

### Cost Limits

Stop workflow if cost exceeds threshold:

```ruby
module <%= @root_namespace %>
  class BudgetedWorkflow < RubyLLM::Agents::Workflow::Pipeline
    max_cost 1.00  # Stop if workflow exceeds $1.00

    step :expensive_analysis, agent: DeepAnalysisAgent
    step :synthesis,          agent: SynthesisAgent
  end
end
```

## Testing Workflows

```ruby
RSpec.describe <%= @root_namespace %>::ContentPipeline do
  describe ".call" do
    it "processes content through all steps" do
      result = described_class.call(text: "test input")

      expect(result.success?).to be true
      expect(result.steps.keys).to eq([:extract, :validate, :format])
    end

    it "handles step failures" do
      allow(ExtractorAgent).to receive(:call).and_raise("Network error")

      result = described_class.call(text: "test")

      expect(result.error?).to be true
      expect(result.errors[:extract]).to be_present
    end
  end
end
```

## Best Practices

1. **Version your workflows** - Track changes for debugging
2. **Set timeouts** - Prevent runaway workflows
3. **Use max_cost** - Control spending on expensive operations
4. **Handle errors gracefully** - Use optional steps and error handlers
5. **Keep workflows focused** - One workflow, one purpose
6. **Test step interactions** - Unit test agents, integration test workflows
7. **Log workflow execution** - Track step timing and costs
8. **Use parallel for independent operations** - Improve throughput
9. **Use router for classification** - Keep routing logic centralized
