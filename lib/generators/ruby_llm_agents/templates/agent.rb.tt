# frozen_string_literal: true
<% if namespaced? -%>
<% namespace_parts.each_with_index do |mod, i| -%>
<%= '  ' * i %>module <%= mod %>
<% end -%>
<%= '  ' * namespace_parts.length %>class <%= agent_class_name %>Agent < ApplicationAgent
<% else -%>
class <%= agent_class_name %>Agent < ApplicationAgent
<% end -%>
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Model Configuration
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>model "<%= options[:model] %>"
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>temperature <%= options[:temperature] %>
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>version "1.0"
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># timeout 30  # Per-request timeout in seconds (default: 60)

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Caching
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================

<% if options[:cache] -%>
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>cache <%= options[:cache] %>
<% else -%>
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># cache 1.hour  # Enable response caching with TTL
<% end -%>

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Reliability (Retries & Fallbacks)
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Automatic retries with exponential backoff
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># - max: Number of retry attempts
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># - backoff: :constant or :exponential
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># - base: Base delay in seconds
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># - max_delay: Maximum delay between retries
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># - on: Additional error classes to retry on
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># retries max: 2, backoff: :exponential, base: 0.4, max_delay: 3.0

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Fallback models (tried in order when primary model fails)
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># fallback_models ["gpt-4o-mini", "claude-3-haiku"]

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Total timeout across all retry/fallback attempts
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># total_timeout 30

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Circuit breaker (prevents repeated calls to failing models)
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># - errors: Number of errors to trigger open state
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># - within: Rolling window in seconds
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># - cooldown: Time to wait before allowing requests again
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># circuit_breaker errors: 5, within: 60, cooldown: 300

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Parameters
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================

<% parsed_params.each do |param| -%>
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>param :<%= param.name %><%= ", required: true" if param.required? %><%= ", default: #{param.default.inspect}" if param.default && !param.required? %>
<% end -%>

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>private

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Prompts (required)
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>def system_prompt
<%= '  ' * (namespaced? ? namespace_parts.length + 2 : 2) %><<~PROMPT
<%= '  ' * (namespaced? ? namespace_parts.length + 3 : 3) %>You are a helpful assistant.
<%= '  ' * (namespaced? ? namespace_parts.length + 3 : 3) %># Define your system instructions here
<%= '  ' * (namespaced? ? namespace_parts.length + 2 : 2) %>PROMPT
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>end

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>def user_prompt
<%= '  ' * (namespaced? ? namespace_parts.length + 2 : 2) %># Build the prompt from parameters
<% if parsed_params.any? -%>
<%= '  ' * (namespaced? ? namespace_parts.length + 2 : 2) %><%= parsed_params.first.name %>
<% else -%>
<%= '  ' * (namespaced? ? namespace_parts.length + 2 : 2) %>"Your prompt here"
<% end -%>
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>end

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Optional Overrides
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># ============================================

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Structured output schema (returns parsed hash instead of raw text)
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># def schema
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#   @schema ||= RubyLLM::Schema.create do
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#     string :result, description: "The result"
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#     integer :confidence, description: "Confidence score 1-100"
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#     array :tags, description: "Relevant tags" do
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#       string
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#     end
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#   end
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># end

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Custom response processing (default: symbolize hash keys)
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># def process_response(response)
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#   content = response.content
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#   # Transform or validate the response
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#   content
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># end

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Custom metadata to include in execution logs
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># def execution_metadata
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#   { custom_field: "value", request_id: params[:request_id] }
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># end

<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># Custom cache key data (default: all params except skip_cache, dry_run)
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># def cache_key_data
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %>#   { query: params[:query], locale: I18n.locale }
<%= '  ' * (namespaced? ? namespace_parts.length + 1 : 1) %># end
<% if namespaced? -%>
<%= '  ' * namespace_parts.length %>end
<% namespace_parts.reverse.each_with_index do |mod, i| -%>
<%= '  ' * (namespace_parts.length - i - 1) %>end
<% end -%>
<% else -%>
end
<% end -%>
