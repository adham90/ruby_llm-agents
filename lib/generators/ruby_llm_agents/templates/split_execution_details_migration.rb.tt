# frozen_string_literal: true

class SplitExecutionDetailsFromExecutions < ActiveRecord::Migration<%= migration_version %>
  def up
    # 1. Create the new execution_details table
    create_table :ruby_llm_agents_execution_details do |t|
      t.references :execution, null: false,
                   foreign_key: { to_table: :ruby_llm_agents_executions, on_delete: :cascade },
                   index: { unique: true }

      t.text     :error_message
      t.text     :system_prompt
      t.text     :user_prompt
      t.json     :response,             default: {}
      t.json     :messages_summary,     default: {}, null: false
      t.json     :tool_calls,           default: [], null: false
      t.json     :attempts,             default: [], null: false
      t.json     :fallback_chain
      t.json     :parameters,           default: {}, null: false
      t.string   :routed_to
      t.json     :classification_result
      t.datetime :cached_at
      t.integer  :cache_creation_tokens, default: 0

      t.timestamps
    end

    # 2. Backfill existing data in batches
    say_with_time "Backfilling execution_details" do
      batch_size = 1000
      count = 0
      loop do
        ids = exec_query(<<~SQL).rows.flatten
          SELECT e.id FROM ruby_llm_agents_executions e
          LEFT JOIN ruby_llm_agents_execution_details d ON d.execution_id = e.id
          WHERE d.id IS NULL
            AND (e.error_message IS NOT NULL
              OR e.system_prompt IS NOT NULL
              OR e.user_prompt IS NOT NULL
              OR e.response IS NOT NULL
              OR e.tool_calls IS NOT NULL
              OR e.attempts IS NOT NULL
              OR e.routed_to IS NOT NULL)
          ORDER BY e.id
          LIMIT #{batch_size}
        SQL

        break if ids.empty?

        execute <<~SQL
          INSERT INTO ruby_llm_agents_execution_details
            (execution_id, error_message, system_prompt, user_prompt, response,
             messages_summary, tool_calls, attempts, fallback_chain, parameters,
             routed_to, classification_result, cached_at, cache_creation_tokens,
             created_at, updated_at)
          SELECT id, error_message, system_prompt, user_prompt, response,
                 COALESCE(messages_summary, '{}'), COALESCE(tool_calls, '[]'),
                 COALESCE(attempts, '[]'), fallback_chain, COALESCE(parameters, '{}'),
                 routed_to, classification_result, cached_at, cache_creation_tokens,
                 created_at, updated_at
          FROM ruby_llm_agents_executions
          WHERE id IN (#{ids.join(',')})
        SQL

        count += ids.size
      end
      count
    end

    # 3. Drop columns moved to execution_details
    remove_column :ruby_llm_agents_executions, :error_message, :text
    remove_column :ruby_llm_agents_executions, :system_prompt, :text
    remove_column :ruby_llm_agents_executions, :user_prompt, :text
    remove_column :ruby_llm_agents_executions, :response, :json
    remove_column :ruby_llm_agents_executions, :messages_summary, :json
    remove_column :ruby_llm_agents_executions, :tool_calls, :json
    remove_column :ruby_llm_agents_executions, :attempts, :json
    remove_column :ruby_llm_agents_executions, :fallback_chain, :json
    remove_column :ruby_llm_agents_executions, :parameters, :json
    remove_column :ruby_llm_agents_executions, :routed_to, :string
    remove_column :ruby_llm_agents_executions, :classification_result, :json
    remove_column :ruby_llm_agents_executions, :cached_at, :datetime
    remove_column :ruby_llm_agents_executions, :cache_creation_tokens, :integer

    # 4. Drop niche columns moved to metadata JSON
    remove_column :ruby_llm_agents_executions, :span_id, :string if column_exists?(:ruby_llm_agents_executions, :span_id)
    remove_column :ruby_llm_agents_executions, :response_cache_key, :string if column_exists?(:ruby_llm_agents_executions, :response_cache_key)
    remove_column :ruby_llm_agents_executions, :time_to_first_token_ms, :integer if column_exists?(:ruby_llm_agents_executions, :time_to_first_token_ms)
    remove_column :ruby_llm_agents_executions, :retryable, :boolean if column_exists?(:ruby_llm_agents_executions, :retryable)
    remove_column :ruby_llm_agents_executions, :rate_limited, :boolean if column_exists?(:ruby_llm_agents_executions, :rate_limited)
    remove_column :ruby_llm_agents_executions, :fallback_reason, :string if column_exists?(:ruby_llm_agents_executions, :fallback_reason)

    # 5. Drop tenant_record polymorphic (redundant â€” access via tenant)
    remove_index :ruby_llm_agents_executions, column: [:tenant_record_type, :tenant_record_id],
                 name: "index_executions_on_tenant_record", if_exists: true
    remove_column :ruby_llm_agents_executions, :tenant_record_type, :string if column_exists?(:ruby_llm_agents_executions, :tenant_record_type)
    remove_column :ruby_llm_agents_executions, :tenant_record_id, :string if column_exists?(:ruby_llm_agents_executions, :tenant_record_id)

    # 6. Add missing columns if not present
    unless column_exists?(:ruby_llm_agents_executions, :execution_type)
      add_column :ruby_llm_agents_executions, :execution_type, :string, null: false, default: "chat"
    end
    unless column_exists?(:ruby_llm_agents_executions, :chosen_model_id)
      add_column :ruby_llm_agents_executions, :chosen_model_id, :string
    end
    unless column_exists?(:ruby_llm_agents_executions, :messages_count)
      add_column :ruby_llm_agents_executions, :messages_count, :integer, default: 0, null: false
    end

    # 7. Drop unused indexes
    remove_index :ruby_llm_agents_executions, :duration_ms, if_exists: true
    remove_index :ruby_llm_agents_executions, :total_cost, if_exists: true
    remove_index :ruby_llm_agents_executions, :messages_count, if_exists: true
    remove_index :ruby_llm_agents_executions, :attempts_count, if_exists: true
    remove_index :ruby_llm_agents_executions, :tool_calls_count, if_exists: true
    remove_index :ruby_llm_agents_executions, :chosen_model_id, if_exists: true
    remove_index :ruby_llm_agents_executions, :execution_type, if_exists: true
    remove_index :ruby_llm_agents_executions, :response_cache_key, if_exists: true
    remove_index :ruby_llm_agents_executions, :agent_type, if_exists: true
    remove_index :ruby_llm_agents_executions, :tenant_id, if_exists: true

    # 8. Add composite tenant indexes if missing
    unless index_exists?(:ruby_llm_agents_executions, [:tenant_id, :created_at])
      add_index :ruby_llm_agents_executions, [:tenant_id, :created_at]
    end
    unless index_exists?(:ruby_llm_agents_executions, [:tenant_id, :status])
      add_index :ruby_llm_agents_executions, [:tenant_id, :status]
    end
  end

  def down
    # Re-add detail columns
    add_column :ruby_llm_agents_executions, :error_message, :text
    add_column :ruby_llm_agents_executions, :system_prompt, :text
    add_column :ruby_llm_agents_executions, :user_prompt, :text
    add_column :ruby_llm_agents_executions, :response, :json
    add_column :ruby_llm_agents_executions, :messages_summary, :json
    add_column :ruby_llm_agents_executions, :tool_calls, :json
    add_column :ruby_llm_agents_executions, :attempts, :json
    add_column :ruby_llm_agents_executions, :fallback_chain, :json
    add_column :ruby_llm_agents_executions, :parameters, :json
    add_column :ruby_llm_agents_executions, :routed_to, :string
    add_column :ruby_llm_agents_executions, :classification_result, :json
    add_column :ruby_llm_agents_executions, :cached_at, :datetime
    add_column :ruby_llm_agents_executions, :cache_creation_tokens, :integer

    # Re-add niche columns
    add_column :ruby_llm_agents_executions, :span_id, :string
    add_column :ruby_llm_agents_executions, :response_cache_key, :string
    add_column :ruby_llm_agents_executions, :time_to_first_token_ms, :integer
    add_column :ruby_llm_agents_executions, :retryable, :boolean
    add_column :ruby_llm_agents_executions, :rate_limited, :boolean
    add_column :ruby_llm_agents_executions, :fallback_reason, :string

    # Re-add tenant_record polymorphic
    add_column :ruby_llm_agents_executions, :tenant_record_type, :string
    add_column :ruby_llm_agents_executions, :tenant_record_id, :string
    add_index :ruby_llm_agents_executions, [:tenant_record_type, :tenant_record_id],
              name: "index_executions_on_tenant_record"

    # Copy data back from execution_details
    say_with_time "Restoring detail data to executions" do
      count = 0
      batch_size = 1000
      loop do
        rows = exec_query(<<~SQL).to_a
          SELECT * FROM ruby_llm_agents_execution_details
          ORDER BY id LIMIT #{batch_size} OFFSET #{count}
        SQL

        break if rows.empty?

        rows.each do |row|
          execute <<~SQL
            UPDATE ruby_llm_agents_executions
            SET error_message = #{quote(row['error_message'])},
                system_prompt = #{quote(row['system_prompt'])},
                user_prompt = #{quote(row['user_prompt'])},
                response = #{quote(row['response'])},
                messages_summary = #{quote(row['messages_summary'])},
                tool_calls = #{quote(row['tool_calls'])},
                attempts = #{quote(row['attempts'])},
                fallback_chain = #{quote(row['fallback_chain'])},
                parameters = #{quote(row['parameters'])},
                routed_to = #{quote(row['routed_to'])},
                classification_result = #{quote(row['classification_result'])},
                cached_at = #{quote(row['cached_at'])},
                cache_creation_tokens = #{quote(row['cache_creation_tokens'])}
            WHERE id = #{row['execution_id']}
          SQL
        end

        count += rows.size
      end
      count
    end

    drop_table :ruby_llm_agents_execution_details
  end
end
